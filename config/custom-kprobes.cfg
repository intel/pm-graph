#
# This is the configuration file for analyze_suspend. It contains
# all the tool arguments so that they don't have to be given on the
# command line. It also includes advanced settings for functions
# and kprobes. It is run like this
#
#    sudo ./analyze_suspend.py -config thisfile.txt
#

[Settings]

# Verbosity
# print verbose messages (default: false)
verbose: false

# Suspend Mode
# e.g. standby, mem, freeze, disk (default: mem)
mode: mem

# Automatic Wakeup
# Use rtcwake to autoresume after X seconds (default: infinity)
rtcwake: 15

# Add Logs
# add the dmesg and ftrace log to the html output (default: false)
addlogs: false

# Display function calls
# graph source functions in the timeline (default: false)
dev: false

# Callgraph
# gather detailed ftrace callgraph data on all timeline events (default: false)
callgraph: false

# Back to Back Suspend/Resume
# Run two suspend/resumes back to back (default: false)
x2: false

# Back to Back Suspend Delay
# Time delay between the two test runs in ms (default: 0 ms)
x2delay: 0

# Post Resume Time
# Time after resume completion to wait for post-resume events (default: 0 S)
postres: 15

# Minimum Device Length
# graph only devices longer than min in the timeline (default: 0.001 ms)
mindev: 0.001

# Minimum Callgraph Length
# provide callgraph data for blocks longer than min (default: 1 ms)
mincg: 1

# Suspend/Resume Gap
# insert a small visible gap between suspend and resume on the timeline (default: false)
srgap: false

# Output Directory Format
# output folder for html, ftrace, and dmesg. Use {date} and {time} for current values
output-dir: suspend-{date}-{time}-custom

# Append kprobes
# Append the timeline kprobes in this file to the internal ones (default: true)
append-kprobes: false

# Append dev kprobes
# Append the dev kprobes in this file to the internal ones (default: false)
append-dev-kprobes: false

[Kprobe_x86_64]
_cpu_down: CPU_OFF[{cpu}] cpu=%di:s32 [color=purple]
_cpu_up: CPU_ON[{cpu}] cpu=%di:s32 [color=orange]
sys_sync: [color=c2c2ff]
pm_prepare_console:
pm_notifier_call_chain:
freeze_processes: [color=pink]
freeze_kernel_threads:
pm_restrict_gfp_mask:
acpi_suspend_begin:
suspend_console:
acpi_pm_prepare:
syscore_suspend:
arch_enable_nonboot_cpus_end:
syscore_resume:
acpi_pm_finish: [color=green]
resume_console:
acpi_pm_end:
pm_restore_gfp_mask:
thaw_processes:
pm_restore_console:

[Kprobe_dev_x86_64]
#
# Kprobes for x86_64 Architecture
#
# This is a list of kprobes which use both symbol data and function arg data.
# The function calls are displayed on the timeline alongside the device blocks.
# The args are pulled directly from the stack using this architecture's registers
# and stack formatting. Three pieces of info are required. The function name,
# a format string, and an argument list
#
# Entry format:
#
#   function: format{arg1}_{arg2} arg1 arg2 ...
#
# function: The symbol name for the function you want to probe (required)
#
#   ex: ata_eh_recover
#
# format: The format to display the data on the timeline in. (optional)
#   Use braces to enclose the arg names in order to add them to the string:
#
#   ex: ata{port}_port_reset
# 
# arglist: A list of arguments from registers/stack addresses. (optional)
#   See https://www.kernel.org/doc/Documentation/trace/kprobetrace.txt
#
#   For x86_64: 
#     The 1st 6 function arguments go in registers %di, %si, %dx, %cx, %8, %9
#     respectively, the remaining args are pushed onto the stack. All addresses
#     are 8 bytes (void, int, etc).
#
#   ex: name=+8(%di):string
#   desc: 1st function arg is a struct address, struct member1 is an address,
#         member2 is a string. Get that string and set it to arg "name"
#
#         static int serio_reconnect_port(struct serio *serio) ...
#         struct serio {
#           void *port_data;
#           char name[32];      <------
#           ...
#
#   ex: port=+36(%di):s32
#   desc: 1st function arg is a struct address, 36 bytes in is a 32bit short,
#         get that number and set it to arg "port"
#
#         int ata_eh_recover(struct ata_port *ap, ...
#         struct ata_port {
#           struct Scsi_Host    *scsi_host;
#           struct ata_port_operations *ops;
#           spinlock_t      *lock;
#           unsigned long       flags;
#           unsigned int        pflags;
#           unsigned int        print_id;     <----------
#           ...
#
# Example: Display ATA port reset as ataN_port_reset in the timeline
#
#   ata_eh_recover: ata{port}_port_reset port=+36(%di):s32
#
msleep: msleep time=%di:s32
schedule_timeout_uninterruptible: schedule_timeout_uninterruptible timeout=%di:s32
schedule_timeout: schedule_timeout timeout=%di:s32
usleep_range: usleep_range min=%di:s32 max=%si:s32
__const_udelay: udelay loops=%di:s32
__mutex_lock_slowpath: mutex_lock_slowpath
ata_eh_recover: ata_eh_recover port=+36(%di):s32
acpi_os_stall:
acpi_resume_power_resources:
acpi_ps_parse_aml:
ext4_sync_fs:
i915_gem_resume:
i915_restore_state:
intel_opregion_setup:
g4x_pre_enable_dp:
vlv_pre_enable_dp:
chv_pre_enable_dp:
g4x_enable_dp:
vlv_enable_dp:
intel_hpd_init:
intel_opregion_register:
intel_dp_detect:
intel_hdmi_detect:
intel_opregion_init:
intel_fbdev_set_suspend:
